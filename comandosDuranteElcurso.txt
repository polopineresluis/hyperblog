//abrir archivos en comando
cat

//historia de todos los comandos que he usado
history

//invocar los comandos 
!

//borrar archivo
rm nombredelarchivo

//informacion
rm --help

//limpiar la consola

Ctrl + l

//sacar un archivo
git rm --cached  nombredelarchivo

//mandarlo al repositorio
git commit -m "Este es el primer commit de este archivo"

//configurar git
git config
git config --list
git config --list --show-origin

//nombre y correo
git config user.name
git config user.email

// ver historia del archivo
git  log nombredelarchivo


//COMANDOS MAS AVANZADOS
git show nombreArchivo

git diff se puede hacer comparacion con dos actualizaciones.


//Volver a una funcion vieja
git reset f68b6145c80be36e6ea75ce1602368a36bed0e58 --hard

//
git log --stat

//volver a una version
git checkout .......................

git flech
git merge

//o funciona los dos comandos anteriores por este:
git pull

//git commit y add
git commit -am

//crear rama
git branch cabecera

// cambiar de rama
git checkeout cabecera

//funcionando ramas
git merge cabecera


//ahora podemos hacer el merge al reves para cabecera
git merge master

//agregar origin remot

git remote add origin  https://github.com/polopineresluis/hyperblog.git

git remote -v

//enviar la rama master
git push origin master

//traer
git pull origin master

//fucionar
git pull origin master --allow-unrelated-histories

git config -l

//traer cambios del repositorio remoto
git pull origin master


//GENERANDO LLAVES PUBLICAS
ssh-keygen -t rsa -b 4096 -C "polopineresluisfernando@gmail.com"

//ver si esta corriento en windows las llaves ssh
eval $(ssh-agent  -s)

//agregar la llave que se creo
ssh-add ~/.ssh/id_rsa

//cambiar la url para aplicar la ssh
git remote set-url origin  git@github.com:polopineresluis/hyperblog.git

//traerme del remote
git pull
git pull origin master

//
git log --all --graph --decorate --oneline

//
alias arbolito = "git log --all --graph --decorate --oneline"

//tags
git tag -a v0.1 -m "Resultado de las primeras clases del curso" a607462 
git tag
git show-ref --tag

//mandar el tag a internet o al remoto

git pull origin master

//borrar tags

git tag

git tag -d nombreDelTag

//eliminar los tag de una manera especial para el remoto
git push origin :refs/tags/dormido

//ENVIAR DIFERENTES RAMAS AL SERVIDOR

//agregar historia de las ramas
git show-branch --all

gitk

git pull origin master

git push origin cabecera

//Configurar múltiples colaboradores en un repositorio de GitHub
git clone url

//Flujo de trabajo profesional: Haciendo merge de ramas de desarrollo a master

//traerme del remoto la rama
git pull origin nombreRama
git push origin footer


//unir todo el trabajo en una sola rama
git pull origin footer

git checkout master
git merge header 
git pull origin master
git push origin master

//footer
git merge footer
git pull footer
git push origin master
git push origin master

//Flujo de trabajo profesional con Pull requests (cuando alguien extraño hace modificaciones)

//rama para arreglar errores 
git bracnh fix-typo

//Utilizando Pull Requests en GitHub


//Creando un Fork, contribuyendo a un repositorio

//traer un repositorio mas adelantado

git remote add upstream url

Deploy es el proceso que permite enviar al servidor uno o varios archivos. Este servidor puede ser de prueba, desarrollo o producción.

En el siguiente ejemplo veremos cómo se realiza el deployment de un documento en un servidor web básico.

Pasos para hacer deployment en un servidor web:
Entrar a la capeta de los archivos del servidor.
Copiar link en clone, elegir entre HTTPS o SSH del repositorio a contribuir.
-En la carpeta deseada se clona el repositorio:
git clone url
Deploy:


/* DevOps integracion continua o Desarrollo continuo
//travis CI : conecta las ramas de github  con los servidores.

//jenkins tambien es fundamental como travis CI

README.md es el lugar donde se explica de qué trata el proyecto, cómo utilizarlo y demás información que se considere que se deba conocer cualquier persona que vaya a trabajar de alguna forma con el proyecto.
.
Los archivos README son escritos en un lenguaje llamado markdown, por eso la extensión .md, mismo que es un estándar de escritura en diversos sitios (como Platzi, Wikipedia y el mismo GitHub). Aquí puedes ver las reglas de markdown.

Los README.md pueden estar en todas las carpetas, pero el más importante es el que se encuentra en la raíz. Este documento ayuda a que los colaboradores sepan información relevante del proyecto, módulo o sección. Puedes crear cualquier archivo con la extensión .md pero solo los README.md los mostrará por defecto GitHub.

Aporte creado por: David Behar.


GitHub tiene un servicio de hosting gratis llamado GitHub Pages. Con él, puedes tener un repositorio alojado en GitHub y hacer que el contenido se muestre en la web en tiempo real.

Este es un sitio para nuestros proyectos donde lo único que tenemos que hacer es tener un repositorio alojado. En la página, podemos seguir las instrucciones para crear este repositorio

Pasos para subir un repositorio a GitHub Pages
Debemos tomar la llave SSH y hacer un git clone #SSHexample en mi computador local (Home).
Luego, accederemos a la carpeta nueva que aparece en nuestra máquina local.
Creamos un nuevo archivo que se llame index.html
Guardamos los cambios, hacemos un git pull y seguido de esto un git push a master.
Vamos a las opciones de settings de este repositorio y, en la parte de abajo, en la columna Github Pages, configuramos el source o fuente para que traiga la rama master
Guardamos los cambios.
Después de esto, podremos ver nuestro trabajo en la web como si tuviéramos nuestro propio servidor.



Rebase es el proceso de mover o combinar una secuencia de confirmaciones en una nueva confirmación base. La reorganización es muy útil y se visualiza fácilmente en el contexto de un flujo de trabajo de ramas de funciones. El proceso general se puede visualizar de la siguiente manera

git checkout feature
git rebase master

//Ahora, falta fusionar la rama feature con la rama master
git checkout master
git rebase feature

# Cambiamos a la rama que queremos traer los cambios
git checkout experiment
# Aplicamos rebase para traer los cambios de la rama que queremos 
git rebase master

//Git Stash: Guardar cambios en memoria y recuperarlos después
git stash

git stash save "mensaje identificador del elemento del stashed"

Obtener elelmentos del stash
git stash pop
git stash pop stash@{<num_stash>}

Para retomar los cambios de una posición específica del Stash puedes utilizar el comando:
git stash apply stash@{<num_stash>}

Listado de elementos en el stash

git stash list

Crear una rama con el stash
git stash branch <nombre_de_la_rama>

Si deseas crear una rama y aplicar un stash específico (obtenido desde git stash list) puedes utilizar el comando:

git stash branch nombre_de_rama stash@{<num_stash>}

Eliminar elementos del stash
git stash drop
git stash drop stash@{<num_stash>}
git stash clear


Consideraciones:
El cambio más reciente (al crear un stash) SIEMPRE recibe el valor 0 y los que estaban antes aumentan su valor.
Al crear un stash tomará los archivos que han sido modificados y eliminados. Para que tome un archivo creado es necesario agregarlo al Staging Area con git add [nombre_archivo] con la intención de que git tenga un seguimiento de ese archivo, o también utilizando el comando git stash -u (que guardará en el stash los archivos que no estén en el staging).
Al aplicar un stash este no se elimina, es buena práctica eliminarlo.
Aporte creado por: David Behar.

//Git Clean: limpiar tu proyecto de archivos no deseados
$ git clean

//Revisar que archivos no tienen seguimiento.
$ git clean --dry-run

//Eliminar los archivos listados de no seguimiento.
$ git clean -f

//Git cherry-pick: traer commits viejos al head de un branch

El uso de git cherry-pick es sencillo y se puede ejecutar de la siguiente manera:

git checkoutmaster
git cherry-pick f

Atención
Cherry-pick es una mala práctica porque significa que estamos reconstruyendo la historia, usa cherry-pick con sabiduría. Si no sabes lo que estás haciendo, mejor evita emplear este comando.

//Git Reset y Reflog: úsese en caso de emergencia

Git guarda todos los cambios aunque decidas borrarlos, al borrar un cambio lo que estás haciendo sólo es actualizar la punta del branch, para gestionar éstas puntas existe un mecanismo llamado registros de referencia o reflogs…La gestión de estos cambios es mediante los hash’es de referencia (o ref) que son apuntadores a los commits…Los recoges registran cuándo se actualizaron las referencias de Git en el repositorio local (sólo en el local), por lo que si deseas ver cómo has modificado la historia puedes utilizar el comando:

git reflog
git reset --HEAD@{6}
git reset --hard 2bbe04d
git checkout Puedes moverte sin realizar ningún cambio al commit exacto de la ref

//Reconstruir commits en Git con amend
git add -A # Para hacer uso de amend los archivos deben de estar en staging
git commit --amend # Remendar último commit
Atención
Usar amend es una mala práctica, sobre todo cuando ya se ha hecho push o pull al repositorio remoto. Al momento de hacer amend con algún commit que esté en remoto, va a generar un conflicto que se va a arreglar haciendo un commit adicional y se perderá el beneficio del amend.

//Buscar en archivos y commits de Git con Grep y log










